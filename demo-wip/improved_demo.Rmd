---
title: "demo_improved_9/17"
author: "Henry He"
date: "2020/9/17"
output: html_document
---
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=14, fig.height=8, echo=TRUE,
                      eval=FALSE,  ## Set to FALSE because this script doesn't run
                      cache=TRUE,
                      warning=FALSE, message=FALSE)
library(chron)
library(devtools)
library(dplyr)
library(tidyr)
library(data.table)
library(ggplot2)
library(gganimate)
library(lubridate)
library(plotly)
library(abind)
## load_all('C:/Users/Administrator/Desktop/flowmix-master/flowmix') ## Replace with the location of on
##                                               ## your computer
load_all('/home/shyun/repos/flowmix/flowmix') ## Replace with the location of on
                                              ## your computer
```

- Load Data 
The file res.RDS will be loaded into a `list` called `res`
Entries of the list will then be extracted and seperately stored
```{r}
filedir = "~/Downloads/for-henry/res.RDS"
## filedir = "C:/Users/Administrator/Documents/GitHub/flowcy-shiny/learning-plotly/res.RDS"
res = readRDS(filedir)

countslist = res$countslist

ylist = res$ylist

mn = res$mn

numclust = res$numclust

TT = length(ylist)

Time <- names(ylist)

```
Read Data 

function: form_pie_table

The `pie` entry of `res` will be extracted, and stored in a new dataframe called pie_table. 

Parameter: list `res` 
Return : a number dependent on res data x 3 dataframe
Pie table has three columns : 
Time: Indicating the time associated with the row
Cluster: Which cluster it belongs to
Prob: The `pie` value extracted from the table

```{r}
##' @param res: A list containing the resulting data from model
##' @return pie_table : data.frame with TT rows and 3 columns
form_pie_table <- function(res){
  pie_table <- data.frame(res$pie)
  pie_table <- setDT(pie_table, keep.rownames = "Time")[]
  colnames(pie_table) <- c("Time", paste0("cluster_", 1:10))
## Reshape it to 3 columns as described above
  pie_table <- pie_table%>%
  gather(var,val,-c(1))%>%
  separate(var,c("type","cluster"))%>%
  .[-2]
  colnames(pie_table) <- c("Time", "Cluster","Prob")
  return(pie_table)
}
pie_table = form_pie_table(res)
head(pie_table)
```
2. mn(cluster means)
function : form_mn_table
Extract `mn` values from 'res' and stored in a new dataframe called mn_table

parameter : list `res`
return : a 2960 x 5 dataframe
diam_mid_pie,chl_small,pe_pie : This three columns contains the cluster means that associated with each of the three dimensions diam_mid,chl_small and pe.
Time: time associated with this row
Cluster: The cluster it belongs to. Int vairable ranging from 1 to 10
```{r}
##' @param res: A list containing the resulting data from model
##' @return _table : data.frame with TT rows and 3 columns
form_mn_table <- function(res){
  dfs = lapply(1:numclust, function(iclust){
  one_table = tibble(diam_mid_pie = mn[,1,iclust],
                     chl_small_pie = mn[,1,iclust],
                     pe_pie = mn[,1,iclust],
                     Time = Time, Cluster = rep(iclust, TT))
  colnames(one_table)[1:3] <- c("diam_mid_pie","chl_small_pie","pe_pie")
  one_table
  })
  mn_table = bind_rows(dfs)
  return(mn_table)
}
mn_table = form_mn_table(res)
```

Combine two dataframe
Thoughts, two dataframe both contained column Cluster, and later our objective is to highlight date based on Cluster. It make sense to merge two dataframe into one insteading of keeping them seperately
function
Note : Time,Cluster columns in two dataframe are identical, we only keep one in our new table.
```{r}
clustered_data_table = merge(pie_table,mn_table)
head(clustered_data_table)
```

In order to plot this three dimensional data, we will  store ylist 
into three sub-dataframes each contains two of the three dimensions
Function : convert_ylist_2d (better name)
parameter: ylist 
return : Three data_frames each containg two of the dimension of ylist 

```{r}
## Function from flowmix file
collapse_3d_to_2d <- function(y, counts, dims=1:2){

  ## Basic checks
  stopifnot(all(dims %in% 1:3))
  stopifnot(length(dims)==2)

  ## Aggregate
  ymat = cbind(y[,dims], counts) %>% as.data.frame()
  names(ymat)[1:2] = c("dim1", "dim2")
  ymat_summary <- ymat %>% group_by(dim1, dim2) %>% summarise(counts=sum(counts)) %>% as.matrix

  ## Basic check
  if(!is.null(colnames(y))){
    colnames(ymat_summary)[1:2] = colnames(y)[dims]
  }

  return(ymat_summary)
}

##' @param ylist: A list containing the resulting data from ylist in res
##' @param table_list: A list of table (dimension choose 2) data frames. The deafult ordering will be...(to be determined)
convert_ylist_2d <- function(ylist){
  ## Setup
  alltimes = names(ylist)
  TT = length(ylist)
  tablist = list()
  dimslist = list(c(1,2), c(2,3), c(3,1))

  ## Obtain all the tables once.
  for(ii in 1:length(dimslist)){

    dims = dimslist[[ii]]

    ## Form the table
    all_2d_tables = lapply(1:TT, function(tt){
      y = ylist[[tt]][,dims]
      counts = countslist[[tt]]
      collapse_3d_to_2d(y, counts, dims=1:2)
    })
    combined_2d_table = do.call(rbind, all_2d_tables) %>% as_tibble()

    ## Add time
    reptimes = sapply(all_2d_tables, nrow)
    times = rep(alltimes, reptimes)
    combined_2d_table[,"Time"] = times
    newname = paste0("counts_", ii)
    combined_2d_table <- rename(combined_2d_table, !!newname:=counts)
    tablist[[ii]] = combined_2d_table
  }
  diam_chl_table <- tablist[[1]]
  pe_chl_table <- tablist[[2]]
  diam_pe_table <- tablist[[3]] 
  return(list(diam_chl_table,pe_chl_table,diam_pe_table))
}
table_list = convert_ylist_2d(ylist)
```
- Plot

```{r}
# Colors
# how to choose color?
# This is set of color is chosen by hand with numclust known to be 10. In general, this should be replaced by 
# a set of colors with length = numclust whose element are chosen from ...(Need to set a range for color)
myColor = c("red","green","orange","blue","brown","deeppink","navyblue","orchid","seagreen","gold")

key <- highlight_key(clustered_data_table,~Cluster)

# create highlight key, which highlights by cluster
pie_plot <- plot_ly(key)%>%
  group_by(Cluster)%>%
  add_lines(x = ~Time , y = ~Prob, color = ~Cluster, colors = myColor ,)%>%
  add_segments(x = ~Time, xend = ~Time, y = 0, yend = 1, frame = ~Time,showlegend = FALSE, color = "red",showlegend = FALSE)

# modify the x-axis  
pie_plot <- pie_plot%>%layout(
  xaxis = list(
    type = "date",
    tickformat = "%d%M%Y",showticklabels = FALSE)
)
pie_plot
```

```{r}
p1 <- plot_ly(as.data.frame(table_list[1]),
              x = ~diam_mid,
              y = ~chl_small,
              size = ~ counts_1,
              type = 'scatter',
              mode = 'markers',
              sizes = c(0,1000), 
              opacity = 0.5,
              alpha = 0.3,
              showlegend = FALSE) %>%
  add_trace(data = key,
            x = ~diam_mid_pie,
            y = ~chl_small_pie,
            frame = ~Time,
            size = 5,
            hoverinfo = 'text',
            text = ~paste("Cluster", Cluster),
            hovertext = ~paste("Cluster", Cluster),
            textposition = "bottom center",
            mode = 'markers+text',
            textfont = list(size = 14),
            opacity = 0.9)
p2 <- plot_ly(as.data.frame(table_list[2]),
              x = ~pe,
              y = ~chl_small,
              size = ~ counts_2,
              type = 'scatter',
              mode = 'markers',
              alpha = 0.3,
              opacity=0.5,
              sizes = c(0,1000),
              showlegend = FALSE)%>%
  add_trace(data = key,
            x = ~pe_pie,
            y = ~chl_small_pie,
            frame = ~Time,
            showlegend = FALSE, 
            size = 5,
            hoverinfo = 'text',
            text = ~paste("Cluster",Cluster),
            hovertext = ~paste("Cluster",Cluster),
            textposition = "bottom center",
            mode = 'markers+text',
            textfont = list(size = 14),
            opacity = 0.9
            )

p3<-plot_ly(as.data.frame(table_list[2]),
            x= ~diam_mid,
            y = ~pe,
            size = ~ counts_3,
            type = 'scatter',
            mode = 'markers',
            opacity=0.5, 
            sizes = c(0,1000),
            alpha = 0.3,
            showlegend = FALSE)%>%
  add_trace(data = key,
            x = ~diam_mid_pie,
            y = ~pe_pie,
            frame = ~Time,
            size = 5,
            hoverinfo = 'text',
            text = ~paste("Cluster",Cluster),
            hovertext = ~paste("Cluster",Cluster),
            textposition = "bottom center",
            mode = 'markers+text',
            textfont = list(size = 14),
            opacity = 0.9
            )
scatterplot <- subplot(p1,p2,p3,shareX = TRUE,shareY = TRUE)
scatterplot
```



# Justin's suggestions

First of all, the quality/readability of the code, and function
definitions + documentation are all greatly improved! Good job on this.

## Some lower-level to-do items 

(**Please include these items in your update emails.**):

* (High priority, within next few days) Make sure that you can load the
  package. (Try pulling again from the master branch of flowmix; I've gotten rid
  of the C++ code from the master branch.)

* This Rmd file is not runnable (See my later comment about this)

* When I make some small fixes and run it, your `p1` doesn't look like what we
  want

![](figures/p1.png)

* (High priority, within next week) Recall I had pointed this out (attached
  next), and we actually made a small toy example in which we could make the
  **scatterplot vary over time**; did you get a chance to do something similar?

> If you look at the code block called `animation1`, it seems that the
>  background scatterplot points (not the cluster means) are not designed to move
>  over time (I could be wrong -- let me know if I am). You only use the first
>  500 columns of the large data frame. What happens when you use more rows, or
>  all rows? Is this too slow, or prohibitive memory-wise? If so, doesn't that
>  mean that this approach either needs to be improved or replaced?

## Some higher level items:

* I'd like you to maintain your helper functions in an R file, called `viz.R`,
  in this repository (by the way, when we get to the point where we have too
  many functions for a single file, we'll of course expand to several files; see
  my next point). This way, we don't have the R functions scattered in the Rmd
  files, which are not meant to be static locations for the function definitions
  to reside.

* Eventually, we'll want to add your files into an R package, named
  "flowmix-viz", in the flowmix github repository. For a short blog post on how
  to make your first R package, there are many resources out there, like [this
  blog
  post](https://tinyheero.github.io/jekyll/update/2015/07/26/making-your-first-R-package.html).
  Let's cross this bridge when we come to it!

* The advantage of having things in an R package is that when we are writing
  scripts using our helper functions, we just need to run `library(flowmix-viz)`
  or `load_all("C:/Users/Administrator/Desktop/flowmix-master/flowmix')` and all
  the functions are encapsulated.


## Some project organization items:

* This Rmd file is not runnable. I've asked about this before, but could you
  always double check whether the file renders *on its own* (i.e. the "knit"
  button in Rstudio), and also upload an accompanying html output file? Recall
  the same point made in `demo_8_27_with_suggestions.Rmd`:

> This document is clearly not knittable. That's, in general, the whole point of
> using R Markdown -- you have a single ".Rmd" file that you can knit to
> **reproduce** your data analysis. I should be able to hit "knit"
> (Ctrl+Shift+K) in my Rstudio and be able to produce a complete document; the
> same one as yours. From hereon, when you share Rmd documents, could you make
> sure that these are completely knittable.
  
* Also, see https://rmarkdown.rstudio.com/authoring_basics.html for how to make
  cleaner Rmd files, with proper headers and subheaders and links, **bold
  faced** and *italics*, quotes and `code`. You can also start by mimicking my
  "learning-plotly.Rmd" style. 
  
* The cleanness and completeness of these Rmd files is **super important** since
  this is the primary way we communicate -- especially we only meet 30 minutes a
  week. If you just scroll up (screenshot attached next), you can see that the
  document is not nearly at a finishing quality of even a homework
  assignment. You should think of these R markdown documents as your periodic
  job progress report -- surely if you were reporting to your boss, you would
  want to have your report made in complete sentences and narrated coherently,
  formatted consistently, and you would also want to polish the report so that
  you can convey clearly what you've done. Your current document looks like
  this:

![](figures/demo-9-17-screenshot.png)


* I realize some of my suggestions are slipping through the cracks. It's
  important to keep track of detailed todo items, especially since ours is
  largely a software implementation project.

* Moving forward, can you write me a short weekly email before our meeting? This
  email would contain:
    + The summary (just a few sentences is fine) for what you've done so this week.
    + Todo items that you've finished this week.
    + Todo items that were (roughly in priority order, if applicable).
